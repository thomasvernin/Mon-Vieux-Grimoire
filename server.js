const express = require('express');
const app = express();
const { User, Book } = require("./db/mongo");
const cors = require("cors");
const bcrypt = require("bcrypt");
const multer = require("multer");
const path = require('path');
const fs = require('fs');

const PORT = 4000;

// Middleware pour la gestion des uploads d'images avec multer
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        const uploadPath = path.join(__dirname, "uploads");
        if (!fs.existsSync(uploadPath)) {
            fs.mkdirSync(uploadPath, { recursive: true });
        }
        cb(null, uploadPath);
    },
    filename: function (req, file, cb) {
        const fileName = file.originalname.toLowerCase().split(' ').join('-') + '-' + Date.now() + path.extname(file.originalname);
        cb(null, fileName);
    }
});

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 5 }, // Limite de taille de fichier (5MB)
    fileFilter: (req, file, cb) => {
        // Vérifiez le type de fichier
        const filetypes = /jpeg|jpg|png/;
        const mimetype = filetypes.test(file.mimetype);
        const extname = filetypes.test(path.extname(file.originalname).toLowerCase());

        if (mimetype && extname) {
            return cb(null, true);
        } else {
            cb("Error: Only images are allowed!");
        }
    }
});

// Middleware pour autoriser les requêtes cross-origin
app.use(cors());

// Middleware pour traiter les données JSON
app.use(express.json());

// Middleware pour servir les fichiers statiques depuis le répertoire 'uploads'
app.use("/images", express.static(path.join(__dirname, "uploads")));

// Route de test
app.get('/', (req, res) => {
    res.send('Hello World');
});

// Route pour l'inscription
app.post("/api/auth/signup", async (req, res) => {
    const { email, password } = req.body;

    try {
        const userInDb = await User.findOne({ email: email });
        if (userInDb) {
            return res.status(400).send("Email already exists");
        }

        const hashedPassword = await bcrypt.hash(password, 10);

        const user = new User({
            email: email,
            password: hashedPassword
        });

        await user.save();
        res.send({
            message: "Sign up successful",
            hashedPassword: hashedPassword
        });
    } catch (e) {
        console.error("Error in signUp:", e);
        res.status(500).send("Something went wrong");
    }
});

// Route pour la connexion
app.post("/api/auth/login", async (req, res) => {
    const { email, password } = req.body;

    try {
        const user = await User.findOne({ email: email });
        if (!user) {
            return res.status(400).send("Invalid email or password");
        }

        const isPasswordValid = await bcrypt.compare(password, user.password);
        if (!isPasswordValid) {
            return res.status(400).send("Invalid email or password");
        }

        res.send({
            userId: user._id,
            token: "token" // Vous pouvez générer un vrai token JWT ici
        });
    } catch (e) {
        console.error("Error in login:", e);
        res.status(500).send("Something went wrong");
    }
});

// Route pour ajouter un livre
app.post("/api/books", upload.single("image"), async (req, res) => {
    const file = req.file;
    if (!file) {
        return res.status(400).send("Image file is required");
    }

    try {
        const { book } = req.body;
        const parsedBook = JSON.parse(book);

        // Enregistrer le chemin de l'image dans le livre
        const imageUrl = `/images/${file.filename}`;
        parsedBook.imageUrl = imageUrl;

        // Enregistrer le livre dans la base de données MongoDB
        const result = await Book.create(parsedBook);

        res.status(201).send({
            message: "Book added successfully",
            book: result
        });
    } catch (e) {
        console.error("Error in postBook:", e);
        res.status(500).send("Something went wrong");
    }
});

// Route pour récupérer tous les livres
app.get("/api/books", async (req, res) => {
    try {
        const books = await Book.find();

        // Transformer les URL des images en URL complètes
        const booksWithFullImageUrl = books.map(book => ({
            ...book.toObject(),
            imageUrl: `http://localhost:4000/images/${path.basename(book.imageUrl)}`
        }));

        res.send(booksWithFullImageUrl);
    } catch (e) {
        console.error("Error in getBooks:", e);
        res.status(500).send("Something went wrong");
    }
});

// Route pour récupérer un livre par ID
app.get("/api/books/:id", async (req, res) => {
    const id = req.params.id;
    try {
        const book = await Book.findById(id);
        if (!book) {
            return res.status(404).send("Book not found");
        }
        book.imageUrl = `http://localhost:4000/images/${path.basename(book.imageUrl)}`;
        res.send(book);
    } catch (e) {
        console.error("Error in getBookById:", e);
        res.status(500).send("Something went wrong:" + e.message);
    }
});

// Route pour mettre à jour un livre par ID
app.put("/api/books/:id", upload.single("image"), async (req, res) => {
    const id = req.params.id;
    const file = req.file;
    const { book } = req.body;

    try {
        const parsedBook = JSON.parse(book);
        const bookInDb = await Book.findById(id);

        if (!bookInDb) {
            return res.status(404).send("Book not found");
        }

        // Mettre à jour le chemin de l'image si une nouvelle image est téléchargée
        if (file) {
            // Supprimer l'ancienne image associée au livre
            if (bookInDb.imageUrl) {
                const imagePathToDelete = path.join(__dirname, "uploads", path.basename(bookInDb.imageUrl));
                fs.unlink(imagePathToDelete, (err) => {
                    if (err) {
                        console.error("Failed to delete old image:", err);
                    }
                });
            }

            // Mettre à jour le chemin de l'image avec le nouveau fichier
            const imageUrl = `/images/${file.filename}`;
            parsedBook.imageUrl = imageUrl;
        } else {
            // Conserver l'ancien chemin d'image si aucun nouveau fichier n'est téléchargé
            parsedBook.imageUrl = bookInDb.imageUrl;
        }

        // Mettre à jour chaque champ modifié du livre
        for (let prop in parsedBook) {
            if (parsedBook.hasOwnProperty(prop)) {
                bookInDb[prop] = parsedBook[prop];
            }
        }

        // Enregistrer les modifications dans la base de données MongoDB
        const updatedBook = await bookInDb.save();

        // Mettre à jour l'URL complète de l'image dans la réponse
        updatedBook.imageUrl = `http://localhost:4000/images/${path.basename(updatedBook.imageUrl)}`;

        res.send({
            message: "Book updated successfully",
            book: updatedBook
        });
    } catch (e) {
        console.error("Error in updateBook:", e);
        res.status(500).send("Something went wrong: " + e.message);
    }
});







// Route pour supprimer un livre par ID
app.delete("/api/books/:id", async (req, res) => {
    const id = req.params.id;
    try {
        const book = await Book.findByIdAndDelete(id);
        if (!book) {
            return res.status(404).send("Book not found");
        }

        // Supprimer le fichier d'image associé
        const imagePath = path.join(__dirname, "uploads", path.basename(book.imageUrl));
        fs.unlink(imagePath, (err) => {
            if (err) {
                console.error("Failed to delete image file:", err);
            }
        });

        res.send({
            message: "Book deleted successfully",
            book: book
        });
    } catch (e) {
        console.error("Error in deleteBook:", e);
        res.status(500).send("Something went wrong:" + e.message);
    }
});

// Démarrer le serveur
app.listen(PORT, () => {
    console.log(`Server is running on: ${PORT}`);
});











































  







































  




































  



































  


































  





































  

































  






































  







































  




































  



































  


































  





































  

































  

















































  







































  




































  



































  


































  





































  

































  






































  







































  




































  



































  


































  





































  

































  















































  







































  




































  



































  


































  





































  

































  






































  







































  




































  



































  


































  





































  

































  


















































  







































  




































  



































  


































  





































  

































  






































  







































  




































  



































  


































  





































  

































  

















































  







































  




































  



































  


































  





































  

































  






































  







































  




































  



































  


































  





































  

































  















































  







































  




































  



































  


































  





































  

































  






































  







































  




































  



































  


































  





































  

































  











